/**
 * @file % !FILENAME %
 *
 * @section desc File description
 *
 * External interrupts init and acknowledge functions for % !CPUNAME %
 * Automatically generated by goil on % !TIMESTAMP %
 * from root OIL file % !OILFILENAME %
 *
 * @section copyright Copyright
 *
 * Trampoline OS
 *
 * Trampoline is copyright (c) IRCCyN 2005-2007
 * Trampoline is protected by the French intellectual property law.
 *
 * This software is distributed under the Lesser GNU Public Licence
 *
 * @section infos File informations
 *
 * $Date$
 * $Rev$
 * $Author$
 * $URL$
 */
%
#------------------------------------------------------------------------------*
# build an empty list when the list does not exist. This simplify
# further processing because existence test is not necessary

let INTERCORE_INTERRUPT := exists INTERCORE_INTERRUPT default (@( ))
%
/*=============================================================================
 * External interrupts configuration structures
 */
% let IRQ_MAX_PRIO := 15%
/*-----------------------------------------------------------------------------
 *  IRQ priorities : - Ticks/WDT (highest priority) : % !IRQ_MAX_PRIO %
 *                   - Intercore                    : % !IRQ_MAX_PRIO - 1 %
 *                   - ISRS                         : [1, % !IRQ_MAX_PRIO - 2 %]
 *                   - Unused                       : 0
 */
#define IRQ_MAX_PRIO   % !IRQ_MAX_PRIO %
#define IRQ_UNUSED     0
%
###############################################################################
#   tpl_init_isr_prio
#

let interrupt_map := mapof INTERRUPT by NAME
let isr_map := mapof ISRS by NAME
%
#include "tpl_registers.h"

#define OS_START_SEC_CODE
#include "tpl_memmap.h"

FUNC(void, OS_CODE) tpl_init_isr_prio(void)
{
  VAR(uint16, AUTOMATIC) isr_index;
%
loop core_id from 0 to OS::NUMBER_OF_CORES - 1 do
%
  /* =====================
   *    CORE %!core_id%
   */
  /* Reset priorities */
  for(isr_index = 0; isr_index < % !INTERRUPT_COUNT::IT_TABLE_SIZE%; isr_index++)
  {
    TPL_INTC(%!core_id%).PSR[isr_index] = 0;
  }

  /* ISR Priorities */
%
# Get the maximum priority of used IRQs
let max_irq_prio := @( )
foreach app in APPLICATION do
  if app::CORE == core_id then
    foreach isr_app in exists app::ISR default (@( )) do
      let isr := isr_map[isr_app::VALUE]
      if exists max_irq_prio[isr::SOURCE] then
        if max_irq_prio[isr::SOURCE]::PRIORITY < isr::PRIORITY then
          let max_irq_prio[isr::SOURCE] := isr
        end if
      else
        let max_irq_prio[isr::SOURCE] := isr
      end if
    end foreach
  end if
end foreach

# Sort them by priority
let sorted_isrs := @( )
foreach isr in max_irq_prio do
  let sorted_isrs += isr
end foreach
sort sorted_isrs by PRIORITY <

# Print them by order
foreach isr in sorted_isrs do
  let interrupt := interrupt_map[isr::SOURCE]
  let prio := INDEX + 1
  if prio > (IRQ_MAX_PRIO - 2) then
    let prio := IRQ_MAX_PRIO
  end if
%  TPL_INTC(%!core_id%).PSR[% !interrupt::ID %] = % !prio %; /* % !isr::SOURCE % */
%
end foreach
%
  /* Tick Counters have the maximum priority */
%
  let counter_map   := mapof COUNTER by NAME

  foreach application in APPLICATION do
    if application::CORE == core_id then
      foreach counter_name in exists application::COUNTER default (@( )) do
        let counter := counter_map[counter_name::VALUE]
        if counter::SOURCE != "decrementer"
         & counter::TYPE == "HARDWARE" then
          let interrupt := interrupt_map[counter::SOURCE]
%  TPL_INTC(%!core_id%).PSR[% !interrupt::ID %] = % !IRQ_MAX_PRIO %; /* % !counter::NAME % */
%
        end if
      end foreach
    end if
  end foreach

%
  /* Intercore interrupts
   * Tick handlers do the rescheduling and ack intercores if needed, so we're
   * giving a lower priority to intercore interrupts.
   */
%
  foreach intercore_it in INTERCORE_INTERRUPT do
    if intercore_it::CORE == core_id then
    %  TPL_INTC(%!core_id%).PSR[% !interrupt_map[intercore_it::SOURCE]::ID %] = % !IRQ_MAX_PRIO - 1%; /* % !intercore_it::NAME % */
%
    end if
  end foreach
end loop
%
}

%
###############################################################################
#   tpl_load_pits
#

let channel_map := @( )
let channel_map["pit_ch0"] := "TPL_PIT_0"
let channel_map["pit_ch1"] := "TPL_PIT_1"
let channel_map["pit_ch2"] := "TPL_PIT_2"
let channel_map["pit_ch3"] := "TPL_PIT_3"

# Get a list of used pit channels (with no duplicates)
let used_pit_channels := @( )
foreach counter in HARDWARECOUNTERS do
  if counter::SOURCE != "decrementer"
   & counter::HANDLER == "tick" then
    let used_pit_channels[counter::SOURCE] := counter
  end if
end foreach

if [used_pit_channels length] > 0 then
%

/**
 * tpl_load_pits loads the used pit channels with their initialized values and
 * start the channel
 */
FUNC(void, OS_CODE) tpl_load_pits(void)
{
%
foreach counter in used_pit_channels do
  let channel := channel_map[counter::SOURCE]
%  /* Counter % !counter::SOURCE % */
  PIT_LVR(% !channel %) = % !counter::FREQUENCY %;
  PIT_FR(% !channel %) = PIT_FR_TIF;
  PIT_CR(% !channel %) = PIT_CR_TEN | PIT_CR_TIE;

%
end foreach
%
}
%
end if

###############################################################################
#   tpl_tick_handler
#

let counter_map   := mapof COUNTER by NAME
let interrupt_map := mapof INTERRUPT by NAME

let channel_map := @( )
let channel_map["pit_ch0"] := "TPL_PIT_0"
let channel_map["pit_ch1"] := "TPL_PIT_1"
let channel_map["pit_ch2"] := "TPL_PIT_2"
let channel_map["pit_ch3"] := "TPL_PIT_3"

loop core_id from 0 to OS::NUMBER_OF_CORES - 1 do
  let used_interrupts := @( )
  foreach application in APPLICATION do
    if application::CORE == core_id then
      foreach counter_name in exists application::COUNTER default (@( )) do
        let counter := counter_map[counter_name::VALUE]
        if counter::SOURCE != "decrementer"
         & counter::TYPE == "HARDWARE"
         & counter::HANDLER == "tick" then
          let interrupt := interrupt_map[counter::SOURCE]
          let used_interrupts[counter::SOURCE] := interrupt
        end if
      end foreach
    end if
  end foreach

  foreach interrupt in used_interrupts do
    if OS::NUMBER_OF_CORES > 1 then
%FUNC(tpl_bool, OS_CODE) tpl_tick_handler_% !interrupt::NAME%_% !core_id %(void)
{
  /* FIXME : This date counter works only if there is one hardware counter per
   *         core.
   */
  GET_CURRENT_DATE(%!core_id%) = GET_CURRENT_DATE(%!core_id%) + 1;
  /* Clear interrupt flag */
  PIT_FR(% !channel_map[interrupt::NAME] %) = PIT_FR_TIF;
  tpl_call_counter_tick_% !interrupt::NAME %_% !core_id %();

  /* return true to restore cpu priority */
  return TRUE;
}
%
    else
%FUNC(tpl_bool, OS_CODE) tpl_tick_handler_% !interrupt::NAME%(void)
{
  /* FIXME : This date counter works only if there is one hardware counter per
   *         core.
   */
  GET_CURRENT_DATE(%!core_id%) = GET_CURRENT_DATE(%!core_id%) + 1;
  /* Clear interrupt flag */
  PIT_FR(% !channel_map[interrupt::NAME] %) = PIT_FR_TIF;
  tpl_call_counter_tick_% !interrupt::NAME %();

  /* return true to restore cpu priority */
  return TRUE;
}
%
    end if
  end foreach
end loop

###############################################################################
#   tpl_isr_handler
#

let interrupt_map := mapof INTERRUPT by NAME

foreach isr1 in ISRS1 do
%
extern FUNC(void, OS_CODE) % !isr1::NAME %_function(void);
%
end foreach

foreach isr in ISRS do
%
FUNC(tpl_bool, OS_CODE) tpl_isr_handler_% !isr::NAME %(void) {%

# We need to clear the SSCIR Flag in case of a software interruption.
  if interrupt_map[isr::SOURCE]::TYPE == "SOFTWARE" then%
  /* Ack the software interruption */
%
    let isr_core := 0
    foreach application in APPLICATION do
      foreach app_isr in exists application::ISR default (@( )) do
        if app_isr::VALUE == isr::NAME then
          let isr_core := application::CORE
        end if
      end foreach
    end foreach

%  TPL_INTC(% !isr_core %).SSCIR[% !interrupt_map[isr::SOURCE]::ID %] = INTC_SSCIR_CLR;
%
  end if

  if isr::CATEGORY == 2 then%
  /* Call central interrupt handler */
  tpl_central_interrupt_handler_2((void*)% !isr::NAME %_id);

  /* Do not restore CPU priority until the ISR2 has finished its execution */
  return FALSE;
%
  elsif isr::CATEGORY == 1 then%
  /* Call the ISR function directly */
  %!isr::NAME %_function();

  /* return true to restore cpu priority */
  return TRUE;
%
  end if
%
}
%
end foreach

###############################################################################
#   tpl_intercore_handler
#
let interrupt_map := mapof INTERRUPT by NAME

foreach interrupt in INTERCORE_INTERRUPT do
%
/**
 * @internal
 *
 * This function execute an interrupt sent by another core
 * It is used to force context switch on a given core
 */
FUNC(tpl_bool, OS_CODE) tpl_intercore_handler_% !interrupt::NAME %(void)
{
  /* clear interrupt flag */
  TPL_INTC(% !interrupt::CORE %).SSCIR[% !interrupt_map[interrupt::SOURCE]::ID %] = INTC_SSCIR_CLR;

  /* return true to restore cpu priority */
  return TRUE;
}
%
end foreach

###############################################################################
#   tpl_watchdog_handler
#

let counter_map   := mapof COUNTER by NAME
let interrupt_map := mapof INTERRUPT by NAME

let channel_map := @( )
let channel_map["pit_ch0"] := "TPL_PIT_0"
let channel_map["pit_ch1"] := "TPL_PIT_1"
let channel_map["pit_ch2"] := "TPL_PIT_2"
let channel_map["pit_ch3"] := "TPL_PIT_3"

loop core_id from 0 to OS::NUMBER_OF_CORES - 1 do
  let wdg_counters := @( )
  foreach application in APPLICATION do
    if application::CORE == core_id then
      foreach counter_name in exists application::COUNTER default (@( )) do
        let counter := counter_map[counter_name::VALUE]
        if counter::SOURCE != "decrementer"
         & counter::TYPE == "HARDWARE"
         & counter::HANDLER == "watchdog" then
          let wdg_counters[counter::SOURCE] := counter
        end if
      end foreach
    end if
  end foreach

  foreach counter in wdg_counters do
    let channel := channel_map[counter::SOURCE]
    if OS::NUMBER_OF_CORES > 1 then
%
FUNC(tpl_bool, OS_CODE) tpl_watchdog_handler_% !counter::SOURCE%_% !core_id %(void)%
    else
%
FUNC(tpl_bool, OS_CODE) tpl_watchdog_handler_% !counter::SOURCE%(void)%
    end if
%
{
  /* stops the channel and disable interrupts */
  PIT_CR(% !channel %) = (PIT_CR(% !channel %)) & ~(PIT_CR_TEN | PIT_CR_TIE);

  /* Clear interrupt flag */
  PIT_FR(% !channel %) = PIT_FR_TIF;

  /* Call TimingProtection expiration function */
  tpl_watchdog_expiration();

  /* return true to restore cpu priority */
  return TRUE;
}
%

###############################################################################
#   watchdog set/clear functions
#

%
FUNC(void, OS_CODE) tpl_set_tpwatchdog_% !counter::SOURCE%(
  VAR(tpl_time, AUTOMATIC) delay)
{%
    if counter::SOURCE != "decrementer" then
      let channel := channel_map[counter::SOURCE]%
  /* Load the value */
  PIT_LVR(% !channel %) = % !counter::FREQUENCY % * delay;
  PIT_FR(% !channel %) = PIT_FR_TIF;
  PIT_CR(% !channel %) = PIT_CR_TEN | PIT_CR_TIE;%
    else%
  /* TODO */%
    end if
%
}

FUNC(void, OS_CODE) tpl_cancel_tpwatchdog_% !counter::SOURCE%(void)
{%
    if counter::SOURCE != "decrementer" then
      let channel := channel_map[counter::SOURCE]%
  /* stops the channel and disable interrupts */
  PIT_CR(% !channel %) = (PIT_CR(% !channel %)) & ~(PIT_CR_TEN | PIT_CR_TIE);

  /* Clear interrupt flag */
  PIT_FR(% !channel %) = PIT_FR_TIF;%
    else%
  /* TODO */%
    end if
%
}
%
  end foreach
end loop

%
#define OS_STOP_SEC_CODE
#include "tpl_memmap.h"

/* End of file % !FILENAME % */

