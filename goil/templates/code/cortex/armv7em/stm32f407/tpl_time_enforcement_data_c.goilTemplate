%

import "serviceid"

%/**
 * @file % !FILENAME %
 *
 * @section desc File description
 *
 * Time enforcement data structure generated from application % !CPUNAME %
 * Automatically generated by goil on % !TIMESTAMP %
 * from root OIL file % !OILFILENAME %
 *
 * @section copyright Copyright
 *
 * Trampoline OS
 *
 * Trampoline is copyright (c)
 * CNRS, University of Nantes, Ecole Centrale de Nantes
 * Trampoline is protected by the French intellectual property law.
 *
 * This software is distributed under the GNU Public Licence V2.
 * Check the LICENSE file in the root directory of Trampoline
 *
 *
 * @section infos File informations
 *
 * $Date$
 * $Rev$
 * $Author$
 * $URL$
 */

#include "tpl_app_define.h"
#include "tpl_os_definitions.h"
#include "tpl_compiler.h"
#include "tpl_os_std_types.h"
#include "tpl_service_ids.h"
#include "tpl_os_time_model.h"

#define OS_START_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"

VAR(uint32, OS_VAR) tpl_time_enforcement_timers[TASK_COUNT];

VAR(uint32, OS_VAR) tpl_time_enforcement_timers_init[TASK_COUNT];

#define OS_STOP_SEC_VAR_NOINIT_32BIT
#include "tpl_memmap.h"

#define OS_START_SEC_CONST_32BIT
#include "tpl_memmap.h"

#define TE_STATE_COUNT  10

%
let api_map := serviceid(APIUSED)

let initialStateForTask := @[]

#===============================================================================
# Check the STATE of the TASK
#
foreach task in TASKS do

  if exists task::STATE then  
    let nameOfInitialState
    #---------------------------------------------------------------------------
    # Check exactly one initial state exists
    let numberOfInitialState := 0
    foreach state in task::STATE do
      if exists state::INITIAL default (false) then
        let numberOfInitialState += 1
        let nameOfInitialState := state::NAME
        let initialStateForTask[task::NAME] := nameOfInitialState
      end if
    end foreach
    if numberOfInitialState == 0 then
      error task::STATE : "No INITIAL state defined"
    elsif numberOfInitialState > 1 then 
      error task::STATE : "More than one INITIAL state defined"
    end if
    #---------------------------------------------------------------------------
    # Check target states exists and check syscall related to a transition
    # exists
    let stateMap := [task::STATE mapBy: "NAME"]
    foreach state in stateMap do
#      display state
      foreach trans in exists state::T default ( @() ) do
        if not exists api_map[trans::VALUE] then
          error trans::VALUE : "Unavailable system service"
        end if
        if exists trans::VALUE_S::STATE then
          if not exists stateMap[trans::VALUE_S::STATE] then
            error trans::VALUE_S::STATE : "Target STATE does not exist"
          end if
        end if
      end foreach
    end foreach
    
    #---------------------------------------------------------------------------
    # Generate states related define / structs
%
/*==============================================================================
 * Number of states of task % !task::NAME%
 */
#define NUMBER_OF_STATES_OF_TASK_% !task::NAME tab 50 ![stateMap length]
    foreach state (state_idx) in stateMap
    before %

/*------------------------------------------------------------------------------
 * States of task % !task::NAME%
 */%
    do %
#define TASK_% !task::NAME %_STATE_% !state::NAME tab 50 !state_idx
    end foreach
%

/*------------------------------------------------------------------------------
 * Initial state of task % !task::NAME%
 */
#define INITIAL_STATE_OF_TASK_% !task::NAME tab 50 %TASK_% !task::NAME %_STATE_% !nameOfInitialState


    foreach state in stateMap 
    do
%

/*------------------------------------------------------------------------------
 * Number of transitions for state  % !state::NAME %
 */
#define NUMBER_OF_TRANSITIONS_FROM_STATE_% !state::NAME %_OF_TASK_% !task::NAME tab 70 

      if exists state::T then
        ![state::T length]
      else
        !1
      end if

      foreach transition in  exists state::T default ( @() )
      before
%

/*------------------------------------------------------------------------------
 * Transitions from state % !state::NAME % of task % !task::NAME%
 */
CONST(tpl_te_transition, OS_CONST) tpl_te_transitions_of_% !task::NAME %_from_% !state::NAME %[] = {
%
      do
        let targetState := exists transition::VALUE_S::STATE default (nameOfInitialState)
#        display transition
%    {
        % !api_map[transition::VALUE] %,
        TASK_% !task::NAME %_STATE_% !targetState %,
        % !exists transition::VALUE_S::EFT default (0) %
    }%
      between %,
%
      after %
};
%
      end foreach
    end foreach
    
    # Generate the table indexed by the state givins the transiti
    foreach state in stateMap
    before%
/*------------------------------------------------------------------------------
 * State table of task % !task::NAME %
 */
CONST(tpl_te_outgoings, OS_CONST) tpl_te_states_for_task_% !task::NAME %[] = {
%
    do
%    {
        NUMBER_OF_TRANSITIONS_FROM_STATE_% !state::NAME %_OF_TASK_% !task::NAME%,
        tpl_te_transitions_of_% !task::NAME %_from_% !state::NAME%
    }% 
    between %,
%
    after%
};
%
    end foreach   
  end if  
end foreach

foreach task in TASKS
  before
%
/*------------------------------------------------------------------------------
 * Table indexed by task_id of pointers to the state table of the task
 */
CONSTP2CONST(tpl_te_outgoings, OS_CONST, OS_APPL_CONST) tpl_state_table[] = {
%
  do
    if exists task::STATE then
      %    tpl_te_states_for_task_% !task::NAME
    else
      %    NULL%
    end if
  between %,
%
  after
%
};
%
end foreach

%
#define OS_STOP_SEC_CONST_32BIT
#include "tpl_memmap.h"

#define OS_START_SEC_VAR_8BIT
#include "tpl_memmap.h"
%
foreach task in TASKS
  before
%
/*------------------------------------------------------------------------------
 * Current states of task. Initialized to the initial state
 */
VAR(tpl_te_model_state, OS_APPL_DATA) tpl_te_current_state[] = {
%
  do
    if exists initialStateForTask[task::NAME] then
      %    INITIAL_STATE_OF_TASK_% !task::NAME
    else
      %    0%
    end if
  between %,
%
  after
%
};
%
end foreach
%
#define OS_STOP_SEC_VAR_8BIT
#include "tpl_memmap.h"

