%
#
# Template to generate an dispatch sequence for each
# event of the USART with the CTS event, that is USART1, 2, 3 and 6.
# 

input(it,obj,DEVICE,DEVICE_KIND)

let USART := [
  [DEVICE where: @? __item__::VECTOR == NAME ?, @{ NAME : it::NAME }]
  first
]

let USART_DESC := [
  [DEVICE_KIND where: @? __item__::NAME == KIND ?, @{ KIND: USART::KIND }]
  first
]

let FLAGS := @[]
foreach reg in exists USART_DESC::REGISTER default ( @() ) do
  foreach bit in exists reg::BIT default ( @() ) do
    let FLAGS[bit::NAME] := @{ REG : reg::NAME, LOC : bit::LOC }
  end foreach
end foreach

display FLAGS

let bitForFlag := @[
  "TXE"  : 7,
  "TC"   : 6,
  "RXNE" : 5,
  "ORE"  : 3,
  "IDLE" : 4,
  "PE"   : 0,
  "NF"   : 2,
  "FE"   : 1,
  "LBD"  : 8,
  "CTS"  : 9
]
let bitForEnable := @[
  "TXE"  : @{ BIT:  7, REG: "CR1" },
  "TC"   : @{ BIT:  6, REG: "CR1" },
  "RXNE" : @{ BIT:  5, REG: "CR1" },
  "ORE"  : @{ BIT:  0, REG: "CR3" },
  "IDLE" : @{ BIT:  4, REG: "CR1" },
  "PE"   : @{ BIT:  8, REG: "CR1" },
  "NF"   : @{ BIT:  0, REG: "CR3" },
  "FE"   : @{ BIT:  0, REG: "CR3" },
  "LBD"  : @{ BIT:  6, REG: "CR2" },
  "CTS"  : @{ BIT: 10, REG: "CR3" }
]

if exists obj::SOURCE_S then
  let flagList := @()
  let enableList := @()
  foreach ev in obj::SOURCE_S::EVFLAG do
    if exists bitForFlag[ev::VALUE] then
      let flagList += "1U << " + [bitForFlag[ev::VALUE] string]
      let enableList += bitForEnable[ev::VALUE]
    end if
  end foreach
%
  if ((% !USART::NAME %->SR & (% ![flagList componentsJoinedByString: " | "]%)) &&
      %
    foreach enableBit in enableList do
      %(% !USART::NAME %->% !enableBit::REG % & (1U << % !enableBit::BIT %))%
    between % || %
    end foreach
      %)
    %!obj::NAME %_function();%
end if

